package sm.hardcoded.tile;

import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

public class TestFunction {
	public static void main(String[] args) throws Exception {
		new TestFunction().run();
	}
	
	public void run() throws Exception {
		initSymbols();
		
		Address entry = new Address("007039c0");
		long result = Decompress(entry /* (byte*)input, (int*)param_2, size */);
		System.out.printf("Result: '%08x'\n", result);
	}
	
	private static final String[] REGISTERS = { "RAX", "RCX", "RDX", "RBX", "RSP", "RBP", "RSI", "RDI" };
	private static final String[] EFLAGS = { "OF", "DF", "IF", "TF", "SF", "ZF", "AF", "PF", "CF" };
	
	private MemoryRegion MEMORY;
	private LinkedList<Address> call;
	private Map<String, RLong> regs;
	
	private Map<String, Instruction> INSTRUCTIONS;
	private static final String[][] STRING_INSTRUCTIONS = {
		{ "007039c0", "007039c1", "PUSH", "EBP" },
		{ "007039c1", "007039c3", "MOV", "EBP", "ESP" },
		{ "007039c3", "007039c6", "SUB", "ESP", "0x1c" },
		{ "007039c6", "007039c7", "PUSH", "ESI" },
		{ "007039c7", "007039c9", "MOV", "ESI", "EDX" },
		{ "007039c9", "007039cb", "MOV", "EDX", "ECX" },
		{ "007039cb", "007039ce", "MOV", "dword ptr [EBP + -0x14]", "EDX" },
		{ "007039ce", "007039d0", "TEST", "EDX", "EDX" },
		{ "007039d0", "007039d2", "JNZ", "0x007039da" },
		{ "007039d2", "007039d5", "OR", "EAX", "0xffffffff" },
		{ "007039d5", "007039d6", "POP", "ESI" },
		{ "007039d6", "007039d8", "MOV", "ESP", "EBP" },
		{ "007039d8", "007039d9", "POP", "EBP" },
		{ "007039d9", "007039da", "RET" },
		{ "007039da", "007039dd", "MOV", "EAX", "dword ptr [EBP + 0x8]" },
		{ "007039dd", "007039de", "PUSH", "EBX" },
		{ "007039de", "007039e0", "MOV", "EBX", "EDX" },
		{ "007039e0", "007039e1", "PUSH", "EDI" },
		{ "007039e1", "007039e4", "LEA", "ECX", "[ESI + EAX*0x1]" },
		{ "007039e4", "007039e7", "MOV", "dword ptr [EBP + -0xc]", "ECX" },
		{ "007039e7", "007039ea", "LEA", "EDI", "[ECX + -0x1a]" },
		{ "007039ea", "007039ed", "MOV", "dword ptr [EBP + -0x10]", "EDI" },
		{ "007039ed", "007039ef", "TEST", "EAX", "EAX" },
		{ "007039ef", "007039f1", "JNZ", "0x00703a07" },
		{ "007039f1", "007039f3", "CMP", "byte ptr [EDX]", "AL" },
		{ "007039f3", "007039f4", "POP", "EDI" },
		{ "007039f4", "007039f7", "SETZ", "AL" },
		{ "007039f7", "007039f8", "POP", "EBX" },
		{ "007039f8", "007039f9", "POP", "ESI" },
		{ "007039f9", "00703a00", "LEA", "EAX", "[EAX*0x2 + 0xffffffff]" },
		{ "00703a00", "00703a02", "MOV", "ESP", "EBP" },
		{ "00703a02", "00703a03", "POP", "EBP" },
		{ "00703a03", "00703a04", "RET" },
		{ "00703a04", "00703a07", "MOV", "EDI", "dword ptr [EBP + -0x10]" },
		{ "00703a07", "00703a0a", "MOVZX", "ECX", "byte ptr [EBX]" },
		{ "00703a0a", "00703a0b", "INC", "EBX" },
		{ "00703a0b", "00703a0d", "MOV", "EDX", "ECX" },
		{ "00703a0d", "00703a10", "MOV", "dword ptr [EBP + -0x8]", "ECX" },
		{ "00703a10", "00703a13", "SHR", "EDX", "0x4" },
		{ "00703a13", "00703a16", "MOV", "dword ptr [EBP + -0x4]", "EDX" },
		{ "00703a16", "00703a19", "CMP", "EDX", "0x8" },
		{ "00703a19", "00703a1b", "JA", "0x00703a81" },
		{ "00703a1b", "00703a1d", "CMP", "ESI", "EDI" },
		{ "00703a1d", "00703a1f", "JA", "0x00703a9b" },
		{ "00703a1f", "00703a21", "MOV", "EAX", "dword ptr [EBX]" },
		{ "00703a21", "00703a24", "AND", "ECX", "0xf" },
		{ "00703a24", "00703a26", "MOV", "dword ptr [ESI]", "EAX" },
		{ "00703a26", "00703a29", "MOV", "EAX", "dword ptr [EBX + 0x4]" },
		{ "00703a29", "00703a2b", "ADD", "EBX", "EDX" },
		{ "00703a2b", "00703a2e", "MOV", "dword ptr [EBP + -0x8]", "ECX" },
		{ "00703a2e", "00703a30", "MOV", "ECX", "EBX" },
		{ "00703a30", "00703a33", "MOV", "dword ptr [ESI + 0x4]", "EAX" },
		{ "00703a33", "00703a35", "ADD", "ESI", "EDX" },
		{ "00703a35", "00703a38", "MOV", "dword ptr [EBP + -0x18]", "EBX" },
		{ "00703a38", "00703a3d", "CALL", "0x007022b0" },
		{ "00703a3d", "00703a40", "MOV", "ECX", "dword ptr [EBP + -0x8]" },
		{ "00703a40", "00703a42", "MOV", "EDI", "ESI" },
		{ "00703a42", "00703a45", "MOVZX", "EAX", "AX" },
		{ "00703a45", "00703a48", "ADD", "EBX", "0x2" },
		{ "00703a48", "00703a4a", "SUB", "EDI", "EAX" },
		{ "00703a4a", "00703a4d", "MOV", "dword ptr [EBP + -0x4]", "EAX" },
		{ "00703a4d", "00703a50", "CMP", "ECX", "0xf" },
		{ "00703a50", "00703a52", "JZ", "0x00703a7c" },
		{ "00703a52", "00703a55", "CMP", "EAX", "0x8" },
		{ "00703a55", "00703a57", "JC", "0x00703a7c" },
		{ "00703a57", "00703a59", "MOV", "EAX", "dword ptr [EDI]" },
		{ "00703a59", "00703a5b", "MOV", "dword ptr [ESI]", "EAX" },
		{ "00703a5b", "00703a5e", "MOV", "EAX", "dword ptr [EDI + 0x4]" },
		{ "00703a5e", "00703a61", "MOV", "dword ptr [ESI + 0x4]", "EAX" },
		{ "00703a61", "00703a64", "MOV", "EAX", "dword ptr [EDI + 0x8]" },
		{ "00703a64", "00703a67", "MOV", "dword ptr [ESI + 0x8]", "EAX" },
		{ "00703a67", "00703a6a", "MOV", "EAX", "dword ptr [EDI + 0xc]" },
		{ "00703a6a", "00703a6d", "MOV", "dword ptr [ESI + 0xc]", "EAX" },
		{ "00703a6d", "00703a71", "MOV", "AX", "word ptr [EDI + 0x10]" },
		{ "00703a71", "00703a75", "MOV", "word ptr [ESI + 0x10]", "AX" },
		{ "00703a75", "00703a78", "ADD", "ESI", "0x4" },
		{ "00703a78", "00703a7a", "ADD", "ESI", "ECX" },
		{ "00703a7a", "00703a7c", "JMP", "0x00703a04" },
		{ "00703a7c", "00703a7f", "MOV", "EAX", "dword ptr [EBP + -0x18]" },
		{ "00703a7f", "00703a81", "JMP", "0x00703ade" },
		{ "00703a81", "00703a84", "CMP", "EDX", "0xf" },
		{ "00703a84", "00703a86", "JNZ", "0x00703a9b" },
		{ "00703a86", "00703a88", "XOR", "ECX", "ECX" },
		{ "00703a88", "00703a8b", "MOVZX", "EAX", "byte ptr [EBX]" },
		{ "00703a8b", "00703a8c", "INC", "EBX" },
		{ "00703a8c", "00703a8e", "ADD", "ECX", "EAX" },
		{ "00703a8e", "00703a93", "CMP", "EAX", "0xff" },
		{ "00703a93", "00703a95", "JZ", "0x00703a88" },
		{ "00703a95", "00703a98", "LEA", "EDX", "[ECX + 0xf]" },
		{ "00703a98", "00703a9b", "MOV", "dword ptr [EBP + -0x4]", "EDX" },
		{ "00703a9b", "00703a9e", "MOV", "ECX", "dword ptr [EBP + -0xc]" },
		{ "00703a9e", "00703aa1", "LEA", "EDI", "[EDX + ESI*0x1]" },
		{ "00703aa1", "00703aa4", "LEA", "EAX", "[ECX + -0x8]" },
		{ "00703aa4", "00703aa6", "CMP", "EDI", "EAX" },
		{ "00703aa6", "00703aac", "JA", "0x00703bfb" },
		{ "00703aac", "00703aae", "MOV", "ECX", "EBX" },
		{ "00703aae", "00703ab0", "SUB", "ECX", "ESI" },
		{ "00703ab0", "00703ab3", "MOV", "EAX", "dword ptr [ECX + ESI*0x1]" },
		{ "00703ab3", "00703ab5", "MOV", "dword ptr [ESI]", "EAX" },
		{ "00703ab5", "00703ab9", "MOV", "EAX", "dword ptr [ECX + ESI*0x1 + 0x4]" },
		{ "00703ab9", "00703abc", "MOV", "dword ptr [ESI + 0x4]", "EAX" },
		{ "00703abc", "00703abf", "ADD", "ESI", "0x8" },
		{ "00703abf", "00703ac1", "CMP", "ESI", "EDI" },
		{ "00703ac1", "00703ac3", "JC", "0x00703ab0" },
		{ "00703ac3", "00703ac5", "ADD", "EBX", "EDX" },
		{ "00703ac5", "00703ac7", "MOV", "ESI", "EDI" },
		{ "00703ac7", "00703ac9", "MOV", "ECX", "EBX" },
		{ "00703ac9", "00703ace", "CALL", "0x007022b0" },
		{ "00703ace", "00703ad1", "MOV", "ECX", "dword ptr [EBP + -0x8]" },
		{ "00703ad1", "00703ad4", "MOVZX", "EAX", "AX" },
		{ "00703ad4", "00703ad6", "SUB", "EDI", "EAX" },
		{ "00703ad6", "00703ad9", "MOV", "dword ptr [EBP + -0x4]", "EAX" },
		{ "00703ad9", "00703adc", "AND", "ECX", "0xf" },
		{ "00703adc", "00703ade", "MOV", "EAX", "EBX" },
		{ "00703ade", "00703ae1", "LEA", "EBX", "[EAX + 0x2]" },
		{ "00703ae1", "00703ae4", "MOV", "dword ptr [EBP + -0x8]", "EBX" },
		{ "00703ae4", "00703ae7", "CMP", "ECX", "0xf" },
		{ "00703ae7", "00703ae9", "JNZ", "0x00703b03" },
		{ "00703ae9", "00703aeb", "XOR", "ECX", "ECX" },
		{ "00703aeb", "00703af0", "NOP", "dword ptr [EAX + EAX*0x1]" },
		{ "00703af0", "00703af3", "MOVZX", "EAX", "byte ptr [EBX]" },
		{ "00703af3", "00703af4", "INC", "EBX" },
		{ "00703af4", "00703af6", "ADD", "ECX", "EAX" },
		{ "00703af6", "00703afb", "CMP", "EAX", "0xff" },
		{ "00703afb", "00703afd", "JZ", "0x00703af0" },
		{ "00703afd", "00703b00", "MOV", "dword ptr [EBP + -0x8]", "EBX" },
		{ "00703b00", "00703b03", "ADD", "ECX", "0xf" },
		{ "00703b03", "00703b06", "ADD", "ECX", "0x4" },
		{ "00703b06", "00703b0a", "CMP", "dword ptr [EBP + -0x4]", "0x8" },
		{ "00703b0a", "00703b0d", "LEA", "EDX", "[ECX + ESI*0x1]" },
		{ "00703b0d", "00703b10", "MOV", "dword ptr [EBP + -0x1c]", "EDX" },
		{ "00703b10", "00703b12", "JNC", "0x00703b4d" },
		{ "00703b12", "00703b18", "MOV", "dword ptr [ESI]", "0x0" },
		{ "00703b18", "00703b1b", "MOVZX", "EAX", "byte ptr [EDI]" },
		{ "00703b1b", "00703b1d", "MOV", "byte ptr [ESI]", "AL" },
		{ "00703b1d", "00703b21", "MOVZX", "EAX", "byte ptr [EDI + 0x1]" },
		{ "00703b21", "00703b24", "MOV", "byte ptr [ESI + 0x1]", "AL" },
		{ "00703b24", "00703b28", "MOVZX", "EAX", "byte ptr [EDI + 0x2]" },
		{ "00703b28", "00703b2b", "MOV", "byte ptr [ESI + 0x2]", "AL" },
		{ "00703b2b", "00703b2f", "MOVZX", "EAX", "byte ptr [EDI + 0x3]" },
		{ "00703b2f", "00703b32", "MOV", "byte ptr [ESI + 0x3]", "AL" },
		{ "00703b32", "00703b35", "MOV", "EAX", "dword ptr [EBP + -0x4]" },
		{ "00703b35", "00703b3c", "ADD", "EDI", "dword ptr [EAX*0x4 + 0xe6cab8]" },
		{ "00703b3c", "00703b3e", "MOV", "EAX", "dword ptr [EDI]" },
		{ "00703b3e", "00703b41", "MOV", "dword ptr [ESI + 0x4]", "EAX" },
		{ "00703b41", "00703b44", "MOV", "EAX", "dword ptr [EBP + -0x4]" },
		{ "00703b44", "00703b4b", "SUB", "EDI", "dword ptr [EAX*0x4 + 0xe6cbe0]" },
		{ "00703b4b", "00703b4d", "JMP", "0x00703b5a" },
		{ "00703b4d", "00703b4f", "MOV", "EAX", "dword ptr [EDI]" },
		{ "00703b4f", "00703b51", "MOV", "dword ptr [ESI]", "EAX" },
		{ "00703b51", "00703b54", "MOV", "EAX", "dword ptr [EDI + 0x4]" },
		{ "00703b54", "00703b57", "ADD", "EDI", "0x8" },
		{ "00703b57", "00703b5a", "MOV", "dword ptr [ESI + 0x4]", "EAX" },
		{ "00703b5a", "00703b5d", "MOV", "EAX", "dword ptr [EBP + -0xc]" },
		{ "00703b5d", "00703b60", "ADD", "ESI", "0x8" },
		{ "00703b60", "00703b63", "ADD", "EAX", "-0xc" },
		{ "00703b63", "00703b65", "CMP", "EDX", "EAX" },
		{ "00703b65", "00703b67", "JBE", "0x00703bc8" },
		{ "00703b67", "00703b6a", "MOV", "EAX", "dword ptr [EBP + -0xc]" },
		{ "00703b6a", "00703b6d", "LEA", "ECX", "[EAX + -0x7]" },
		{ "00703b6d", "00703b70", "ADD", "EAX", "-0x5" },
		{ "00703b70", "00703b73", "MOV", "dword ptr [EBP + -0x18]", "ECX" },
		{ "00703b73", "00703b75", "CMP", "EDX", "EAX" },
		{ "00703b75", "00703b7b", "JA", "0x00703c19" },
		{ "00703b7b", "00703b7d", "CMP", "ESI", "ECX" },
		{ "00703b7d", "00703b7f", "JNC", "0x00703bb1" },
		{ "00703b7f", "00703b82", "MOV", "EBX", "dword ptr [EBP + -0x18]" },
		{ "00703b82", "00703b84", "MOV", "EDX", "EDI" },
		{ "00703b84", "00703b86", "MOV", "ECX", "ESI" },
		{ "00703b86", "00703b88", "SUB", "EDX", "ESI" },
		{ "00703b88", "00703b90", "NOP", "dword ptr [EAX + EAX*0x1]" },
		{ "00703b90", "00703b93", "MOV", "EAX", "dword ptr [EDX + ECX*0x1]" },
		{ "00703b93", "00703b95", "MOV", "dword ptr [ECX]", "EAX" },
		{ "00703b95", "00703b99", "MOV", "EAX", "dword ptr [EDX + ECX*0x1 + 0x4]" },
		{ "00703b99", "00703b9c", "MOV", "dword ptr [ECX + 0x4]", "EAX" },
		{ "00703b9c", "00703b9f", "ADD", "ECX", "0x8" },
		{ "00703b9f", "00703ba1", "CMP", "ECX", "EBX" },
		{ "00703ba1", "00703ba3", "JC", "0x00703b90" },
		{ "00703ba3", "00703ba6", "MOV", "EDX", "dword ptr [EBP + -0x1c]" },
		{ "00703ba6", "00703ba8", "MOV", "EAX", "EBX" },
		{ "00703ba8", "00703baa", "SUB", "EAX", "ESI" },
		{ "00703baa", "00703bac", "MOV", "ESI", "EBX" },
		{ "00703bac", "00703baf", "MOV", "EBX", "dword ptr [EBP + -0x8]" },
		{ "00703baf", "00703bb1", "ADD", "EDI", "EAX" },
		{ "00703bb1", "00703bb3", "CMP", "ESI", "EDX" },
		{ "00703bb3", "00703bb5", "JNC", "0x00703bf4" },
		{ "00703bb5", "00703bb7", "MOV", "AL", "byte ptr [EDI]" },
		{ "00703bb7", "00703bba", "LEA", "EDI", "[EDI + 0x1]" },
		{ "00703bba", "00703bbc", "MOV", "byte ptr [ESI]", "AL" },
		{ "00703bbc", "00703bbd", "INC", "ESI" },
		{ "00703bbd", "00703bbf", "CMP", "ESI", "EDX" },
		{ "00703bbf", "00703bc1", "JC", "0x00703bb5" },
		{ "00703bc1", "00703bc3", "MOV", "ESI", "EDX" },
		{ "00703bc3", "00703bc8", "JMP", "0x00703a04" },
		{ "00703bc8", "00703bca", "MOV", "EAX", "dword ptr [EDI]" },
		{ "00703bca", "00703bcc", "MOV", "dword ptr [ESI]", "EAX" },
		{ "00703bcc", "00703bcf", "MOV", "EAX", "dword ptr [EDI + 0x4]" },
		{ "00703bcf", "00703bd2", "MOV", "dword ptr [ESI + 0x4]", "EAX" },
		{ "00703bd2", "00703bd5", "CMP", "ECX", "0x10" },
		{ "00703bd5", "00703bd7", "JBE", "0x00703bf4" },
		{ "00703bd7", "00703bda", "ADD", "ESI", "0x8" },
		{ "00703bda", "00703bdc", "SUB", "EDI", "ESI" },
		{ "00703bdc", "00703be0", "NOP", "dword ptr [EAX]" },
		{ "00703be0", "00703be4", "MOV", "EAX", "dword ptr [EDI + ESI*0x1 + 0x8]" },
		{ "00703be4", "00703be6", "MOV", "dword ptr [ESI]", "EAX" },
		{ "00703be6", "00703bea", "MOV", "EAX", "dword ptr [EDI + ESI*0x1 + 0xc]" },
		{ "00703bea", "00703bed", "MOV", "dword ptr [ESI + 0x4]", "EAX" },
		{ "00703bed", "00703bf0", "ADD", "ESI", "0x8" },
		{ "00703bf0", "00703bf2", "CMP", "ESI", "EDX" },
		{ "00703bf2", "00703bf4", "JC", "0x00703be0" },
		{ "00703bf4", "00703bf6", "MOV", "ESI", "EDX" },
		{ "00703bf6", "00703bfb", "JMP", "0x00703a04" },
		{ "00703bfb", "00703bfd", "CMP", "EDI", "ECX" },
		{ "00703bfd", "00703bff", "JNZ", "0x00703c19" },
		{ "00703bff", "00703c00", "PUSH", "EDX" },
		{ "00703c00", "00703c01", "PUSH", "EBX" },
		{ "00703c01", "00703c02", "PUSH", "ESI" },
		{ "00703c02", "00703c07", "CALL", "0x00d20240" },
		{ "00703c07", "00703c0a", "MOV", "EAX", "dword ptr [EBP + -0x4]" },
		{ "00703c0a", "00703c0d", "ADD", "ESP", "0xc" },
		{ "00703c0d", "00703c10", "SUB", "EAX", "dword ptr [EBP + -0x14]" },
		{ "00703c10", "00703c12", "ADD", "EAX", "EBX" },
		{ "00703c12", "00703c13", "POP", "EDI" },
		{ "00703c13", "00703c14", "POP", "EBX" },
		{ "00703c14", "00703c15", "POP", "ESI" },
		{ "00703c15", "00703c17", "MOV", "ESP", "EBP" },
		{ "00703c17", "00703c18", "POP", "EBP" },
		{ "00703c18", "00703c19", "RET" },
		{ "00703c19", "00703c1c", "MOV", "EAX", "dword ptr [EBP + -0x14]" },
		{ "00703c1c", "00703c1d", "POP", "EDI" },
		{ "00703c1d", "00703c1f", "SUB", "EAX", "EBX" },
		{ "00703c1f", "00703c20", "POP", "EBX" },
		{ "00703c20", "00703c21", "DEC", "EAX" },
		{ "00703c21", "00703c22", "POP", "ESI" },
		{ "00703c22", "00703c24", "MOV", "ESP", "EBP" },
		{ "00703c24", "00703c25", "POP", "EBP" },
		{ "00703c25", "00703c30", "RET" },

		{ "007022b0", "007022b3", "MOV", "AX", "word ptr [ECX]" },
		{ "007022b3", "007022c0", "RET" },
	};
	
	private void initSymbols() {
		regs = new TreeMap<>();
		call = new LinkedList<>();
		INSTRUCTIONS = new HashMap<>();
		
		for(String[] split : STRING_INSTRUCTIONS) {
			Instruction inst = new Instruction(split);
			INSTRUCTIONS.put(split[0], inst);
		}
		
		List<RLong> reg = new ArrayList<>();
		List<RLong> sub = new ArrayList<>();
		for(String s : REGISTERS) {
			reg.add(new RLong(s, 0L));
		}
		
		for(RLong r : reg) {
			if(r.name.endsWith("X")) {
				char mid = r.name.charAt(1);
				sub.add(new RSLong("E" + mid + "X", 0, RSize.DWORD, r));
				sub.add(new RSLong(mid + "X", 0, RSize.WORD, r));
				sub.add(new RSLong(mid + "H", 8, RSize.BYTE, r));
				sub.add(new RSLong(mid + "L", 0, RSize.BYTE, r));
			} else {
				String mid = r.name.substring(1);
				sub.add(new RSLong("E" + mid, 0, RSize.DWORD, r));
				sub.add(new RSLong(mid, 0, RSize.WORD, r));
				sub.add(new RSLong(mid + "L", 0, RSize.BYTE, r));
			}
		}
		
		for(RLong r : reg) regs.put(r.name, r);
		for(RLong r : sub) regs.put(r.name, r);
		for(String s : EFLAGS) regs.put(s, new RFlag(s, false));
		
		for(int i : INT_00e6cab8) TEMP.WriteInt(i).next();
		for(int i : INT_00e6cbe0) TEMP.WriteInt(i).next();
		TEMP.set(0);
		
		MEMORY = new MemoryRegion();
		MEMORY.addRegion("temp"   , TEMP   , 0x00e6cab8, 592);
		MEMORY.addRegion("stack"  , STACK  , 0x70000000, 1000000);
		MEMORY.addRegion("input"  , INPUT  , 0x70000000 + 1000000, 1000000);
		MEMORY.addRegion("param_2", PARAM_2, 0x70000000 + 2000000, 1000000);
	}
	
	private static final int[] INT_00e6cab8 = { 0x0, 0x1, 0x2, 0x1, 0x0, 0x4, 0x4, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x2, 0x0, 0x3, 0x1, 0x3, 0x1, 0x4, 0x2, 0x7, 0x0, 0x2, 0x3, 0x6, 0x1, 0x5, 0x3, 0x5, 0x1, 0x3, 0x4, 0x4, 0x2, 0x5, 0x6, 0x7, 0x7, 0x0, 0x1, 0x2, 0x3, 0x3, 0x4, 0x6, 0x2, 0x6, 0x5, 0x5, 0x3, 0x4, 0x5, 0x6, 0x7, 0x1, 0x2, 0x4, 0x6, 0x4, 0x4, 0x5, 0x7, 0x2, 0x6, 0x5, 0x7, 0x6, 0x7, 0x7, 0x1000b, 0x10 };
	private static final int[] INT_00e6cbe0 = { 0x0, 0x0, 0x0, 0xffffffff, 0xfffffffc, 0x1, 0x2, 0x3, 0x6, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x2, 0x0, 0x3, 0x1, 0x3, 0x1, 0x4, 0x2, 0x7, 0x0, 0x2, 0x3, 0x6, 0x1, 0x5, 0x3, 0x5, 0x1, 0x3, 0x4, 0x4, 0x2, 0x5, 0x6, 0x7, 0x7, 0x0, 0x1, 0x2, 0x3, 0x3, 0x4, 0x6, 0x2, 0x6, 0x5, 0x5, 0x3, 0x4, 0x5, 0x6, 0x7, 0x1, 0x2, 0x4, 0x6, 0x4, 0x4, 0x5, 0x7, 0x2, 0x6, 0x5, 0x7, 0x6, 0x7, 0x7 };
	
	private final Pointer TEMP = new Pointer(592);
	private final Pointer INPUT = new Pointer(1000000, new byte[] { -113, 0, 0, 0, 0, 33, 52, 88, -97, 8, 0, -23, 38, 34, 53, 0, 1, 64, -41, 33, -112, -74, 16, 1, 49, -34, -123, 94, 8, 0, 49, 13, 99, 69, 8, 0, 49, 82, -1, 58, 8, 0, 49, 124, -28, 53, 8, 0, 49, 82, 14, 51, 8, 0, 49, -40, -1, 48, 8, 0, 49, -7, -128, 47, 8, 0, 49, -87, -61, 46, 8, 0, 34, -89, 81, 8, 0, 34, 119, 19, 8, 0, 34, -33, 10, 8, 0, 34, -127, 43, 8, 0, 34, -48, 105, 8, 0, 34, 70, 2, 56, 0, 34, 60, 67, 72, 0, 49, -44, 79, 50, 64, 0, 49, -97, 116, 52, 8, 0, 49, -90, 104, 54, 8, 0, 34, -88, -76, 120, 0, 34, -78, -16, 40, 0, 49, -126, -114, 40, 24, 0, 49, -108, 18, 26, 8, 0, 49, 106, 104, 4, 8, 0, 64, 51, -35, -47, -75, -64, 0, 49, -44, 108, -97, 8, 0, 49, -102, 99, 111, 8, 0, 49, 96, 117, 61, 8, 0, 49, -49, -101, 20, 8, 0, 64, -102, 87, -43, -76, 40, 0, 49, -106, 52, -126, 8, 0, 12, 0, 2, 34, -97, 59, -16, 0, 49, 20, -27, 49, 88, 0, 34, -61, -13, -80, 0, 49, 74, -52, 45, 16, 0, 34, 88, 77, 8, 0, 34, -98, 18, 8, 0, 49, -26, -18, 44, 24, 0, 34, 68, -48, 8, 0, 34, 12, -63, 8, 0, 34, -120, -66, 8, 0, 34, -40, -62, 8, 0, 34, 101, -50, 8, 0, 34, -31, -29, 8, 0, 34, 42, 8, 64, 0, 34, -34, 72, 8, 0, 34, 23, -65, 8, 0, 34, 45, -103, 112, 0, 34, -124, -24, 32, 1, 34, 3, -104, -120, 0, 34, -40, 68, 120, 1, 34, -63, 85, 40, 1, 34, 82, 12, 32, 0, 34, -98, 88, 16, 1, 49, 3, 31, 28, -120, 0, 49, 64, -59, 8, 8, 0, 49, -106, -69, -33, -16, 0, 49, 22, 49, -80, 8, 0, 49, -29, 120, -121, 8, 0, 49, 54, 22, 82, 8, 0, 49, -62, 17, 33, 8, 0, 63, -43, -2, -33, 8, 1, 2, 34, -61, 111, -120, 0, 49, -50, 53, 45, 80, 0, 19, -94, -32, 0, 34, 41, -83, -64, 0, 34, 69, -95, 8, 0, 35, -40, -100, 8, 0, 18, -102, 8, 0, 34, 82, -103, 8, 0, 19, -125, 8, 0, 19, -58, 24, 0, 34, 15, -99, 24, 0, 34, -4, -96, 8, 0, 34, -76, -89, 8, 0, 34, 125, -77, 8, 0, 34, -31, -56, 8, 0, 34, 4, -15, 8, 0, 34, 26, 62, 120, 0, 34, -120, -54, 8, 0, 34, -56, -79, -112, 0, 34, 72, 2, 8, 2, 34, 118, 10, 24, 1, 34, 95, 15, 16, 0, 34, 88, 100, 40, 0, 49, -31, 113, 39, -80, 0, 34, 88, 90, 16, 1, 49, -61, 85, 10, 16, 0, 49, -17, 33, -24, -16, 0, 49, -64, -55, -69, 8, 0, 49, -30, -62, -109, 8, 0, 49, -8, 60, 97, 8, 0, 49, 114, -113, 38, 8, 0, 12, 16, 2, 35, -60, -33, -112, 0, 18, -87, 8, 0, 34, -10, -104, 8, 0, 34, -90, -108, 8, 0, 34, -81, -109, 8, 0, 19, -60, 8, 0, 19, 29, 24, 0, 19, 123, 8, 0, 19, -15, 8, 0, 34, -122, -107, 40, 0, 34, 80, -106, 8, 0, 34, -120, -105, 8, 0, 19, -112, 40, 1, 19, 45, 32, 1, 34, -17, -93, 24, 0, 34, 22, -79, 8, 0, 34, 123, -53, 8, 0, 34, 114, 1, -32, 0, 34, 104, 97, 8, 0, 34, -82, 18, 16, 1, 34, -54, 25, 8, 2, 34, -118, 86, 8, 0, 34, -57, 126, 24, 0, 49, 91, -12, 43, -8, 0, 49, -82, 36, 38, 8, 0, 49, 109, 67, 27, 8, 0, 34, -26, 61, 16, 1, 49, 77, -97, -20, -16, 0, 49, -107, -97, -62, 8, 0, 49, 22, 123, -101, 8, 0, 49, 97, -122, 104, 8, 0, 12, 8, 1, 34, -31, -98, -120, 0, 19, -85, -48, 0, 34, 121, -110, 16, 0, 19, 80, 8, 0, 19, -60, 8, 0, 19, 67, 8, 1, 19, -87, 8, 0, 19, 2, 48, 0, 19, 79, 8, 0, 19, -104, 8, 0, 19, -25, 8, 0, 19, 80, 24, 1, 19, -12, 8, 0, 19, 20, 24, 1, 19, 52, 24, 1, 19, 122, 24, 1, 34, 105, -90, 112, 0, 34, -98, -71, 8, 0, 34, 120, -32, 8, 0, 34, 67, 43, 16, 1, 34, 118, -62, 8, 0, 34, -74, 100, 0, 1, 34, 52, 66, 8, 0, 34, -128, 82, 24, 0, 49, -56, -118, 42, 0, 1, 49, -50, 94, 36, 8, 0, 49, -77, 30, 25, 8, 0, 49, -54, 12, 9, 8, 0, 34, -38, -100, 16, 1, 49, -65, -91, -60, 0, 1, 49, -116, -69, -100, 8, 0, 12, 8, 1, 19, 60, -40, 0, 34, -58, -111, -128, 0, 19, -26, 8, 0, 19, 125, 0, 1, 19, 17, 32, 0, 19, -124, 8, 0, 19, -37, 8, 0, 19, 32, -16, 0, 19, 84, 8, 0, 19, -126, 8, 0, 4, 80, 1, 19, -42, 16, 0, 19, 15, 8, 1, 19, 110, 8, 0, 19, 30, 48, 2, 19, -124, 24, 1, 19, -117, 80, 3, 19, 88, -128, 3, 34, -99, -80, -120, 0, 34, -107, -49, 8, 0, 19, 95, -104, 4, 34, -6, -106, -8, 0, 19, -128, 88, 4, 35, 38, 126, 16, 0, 18, 69, 40, 0, 34, 65, -13, 56, 4, 49, -42, -17, 33, 0, 1, 49, -54, 77, 22, 8, 0, 49, -74, -7, 6, 8, 0, 49, 86, -102, -23, 0, 1, 34, -31, -125, 32, 2, 12, 8, 1, 19, 116, -8, 0, 19, -93, 8, 0, 19, 60, 0, 1, 19, -22, 8, 0, 19, 107, -8, 0, 19, -53, 8, 0, 19, 23, -32, 0, 19, 77, 8, 0, 19, 119, 8, 0, 19, -106, 8, 0, 19, -80, 8, 0, 19, -56, 8, 0, 19, -30, 8, 0, 19, 3, 8, 1, 19, 63, 8, 0, 19, -72, 8, 0, 19, -64, 24, 1, 19, 45, 40, 2, 34, 10, -97, -40, 0, 34, -52, -85, 8, 0, 18, -72, 80, 4, 50, -98, 29, 12, -8, 0, 34, -98, 80, 8, 0, 34, 58, 78, 8, 0, 34, 97, -46, 40, 0, 34, 39, 23, 40, 3, 34, -58, -24, 40, 3, 49, -55, -56, 30, 0, 1, 49, -128, -5, 18, 8, 0, 49, -77, -120, 3, 8, 0, 49, 109, 12, -29, 16, 1, 12, 8, 1, 19, 100, 0, 1, 19, -18, 8, 0, 19, -76, 0, 1, 19, 72, -8, 0, 19, -74, 8, 0, 19, 8, -48, 0, 19, 69, 8, 0, 19, 115, 8, 0, 19, -108, 8, 0, 19, -82, 8, 0, 19, -64, 8, 0, 19, -47, 8, 0, 19, -34, 8, 0, 19, -18, 8, 0, 19, 5, 0, 1, 19, 46, 8, 0, 19, -117, 8, 0, 19, 107, 16, 1, 19, -92, -96, 4, 19, -19, 56, 3, 34, -120, -86, -24, 0, 34, -7, -55, 8, 0, 34, 72, 3, 0, 1, 34, 64, 20, 8, 0, 34, 118, -22, 24, 0, 34, -113, 10, 8, 0, 49, -8, -113, 41, -16, 0, 34, 71, 24, 40, 3, 34, -120, 37, 56, 4, 49, 13, -92, 14, 24, 0, 63, 66, -64, -3, 8, 1, 2, 19, -98, 0, 1, 19, 96, 0, 1, 19, 15, -8, 0, 19, -111, 8, 0, 19, -16, 8, 0, 19, 56, -56, 0, 19, 105, 8, 0, 17, -112, 8, 0, 49, 87, -97, -84, 8, 0, 6, 0, 1, 19, -49, 16, 0, 19, -37, 8, 0, 19, -28, 8, 0, 4, 8, 1, 19, -8, 16, 0, 19, 8, 0, 1, 17, 40, 8, 0, 49, 87, -98, 124, 8, 0, 51, 88, -97, 87, 16, 1, 19, -116, 16, 1, 19, 24, -64, 4, 34, -37, -84, -24, 0, 19, 25, -48, 6, 34, -76, -26, 16, 0, 34, -58, -35, 8, 0, 34, -108, 110, 8, 0, 34, 31, -16, 48, 4, 34, 48, 83, 80, 6, 49, -38, -115, 32, 0, 1, 49, 107, -58, 22, 8, 0, 34, -113, 52, 56, 4, 12, 16, 2, 19, -21, 8, 1, 19, -69, 8, 1, 19, 87, -8, 0, 2, 8, 3, 21, 87, 32, 6, 19, 89, -64, 0, 19, -123, 8, 0, 19, -89, 8, 0, 19, -67, 8, 0, 19, -48, 8, 0, 12, 0, 1, 19, -21, 24, 0, 19, -14, 8, 0, 19, -10, 8, 0, 19, -2, 8, 0, 19, 12, 0, 1, 19, 42, 8, 0, 19, -126, 8, 0, 19, 113, 16, 1, 19, -17, 16, 1, 19, 11, -120, 7, 19, -84, -128, 7, 34, 108, -57, -8, 0, 33, -125, -54, 8, 0, 35, -98, -128, -64, 0, 34, -66, -89, 32, 3, 34, 85, 52, 24, 2, 34, 30, 48, 24, 2, 34, -77, 106, 96, 7, 49, -15, 14, 17, 16, 1, 12, 8, 1, 19, 71, 64, 0, 19, 4, 0, 1, 4, 8, 2, 19, -11, 16, 0, 19, 61, -80, 0, 19, 116, 8, 0, 19, -102, 8, 0, 17, -74, 8, 0, 51, 87, -97, -54, 8, 0, 17, -40, 8, 0, 6, 16, 4, 19, -20, 16, 0, 12, 0, 1, 17, -6, 24, 0, 19, 87, 8, 1, 50, 87, -97, 2, -8, 0, 34, -98, 16, 8, 0, 35, -97, 51, 8, 0, 19, -102, 8, 0, 19, -59, 16, 1, 19, 80, 80, 5, 33, -13, -92, -8, 0, 35, -97, -38, 16, 1, 34, 27, -70, 16, 0, 19, -78, -32, 8, 33, -110, 7, 16, 0, 50, -98, -100, 77, 24, 2, 49, -66, -116, 38, -8, 0, 34, 122, 61, 24, 2, 34, 69, -37, 24, 2, 12, 8, 1, 19, -112, 8, 1, 19, 63, -8, 0, 19, -70, 8, 0, 17, 22, -80, 0, 51, 88, -97, 87, 8, 0, 19, -122, 8, 0, 19, -86, 8, 0, 19, -63, 8, 0, 17, -45, 8, 0, 49, 87, -97, -31, 8, 0, 51, 88, -97, -23, 8, 0, 4, 88, 8, 19, -11, 16, 0, 19, -7, 8, 0, 19, -5, 8, 0, 19, -1, 8, 0, 19, 0, -16, 0, 19, 6, 8, 0, 19, 22, 8, 0, 19, 68, 8, 0, 19, -42, 8, 0, 19, -78, 96, 6, 19, -78, 56, 4, 19, -82, -96, 9, 33, 34, -82, -8, 0, 5, -120, 7, 34, 106, 56, 16, 0, 34, 59, -10, 8, 1, 34, -56, 13, 72, 6, 49, -54, -20, 34, 16, 1, 34, 0, 0, 48, 4, 12, 8, 1, 19, -58, 8, 1, 19, 104, 0, 1, 19, -38, 8, 0, 19, 46, -88, 0, 19, 107, 8, 0, 4, 16, 5, 19, -77, 16, 0, 17, -54, 8, 0, 49, 87, -97, -36, 8, 0, 51, 88, -97, -26, 8, 0, 19, -19, 8, 0, 117, -12, -108, 44, -74, 32, 51, 87, 16, 4, 4, 0, 1, 2, 8, 2, 44, 88, -98, 8, 1, 19, 4, -16, 0, 19, 11, 8, 0, 19, 33, 8, 0, 19, 108, 8, 0, 19, 121, 24, 2, 19, 19, 24, 2, 19, -106, 40, 3, 19, 6, -128, 8, 32, 60, -101, 0, 1, 64, 87, -97, -4, 80, 8, 0, 64, 88, -97, -56, 87, 32, 3, 64, 87, -98, -10, 0, 32, 3, 66, 87, -97, 44, -70, 32, 3, 51, -71, -26, 29, 16, 1, 10, 104, 14, 19, -16, 8, 1, 19, -121, 0, 1, 19, -13, 8, 0, 19, 64, -48, 0, 19, 121, 8, 0, 19, -96, 8, 0, 19, -68, 8, 0, 4, 16, 4, 19, -33, 16, 0, 2, 8, 2, 49, 87, -97, -16, 16, 0, 19, 87, 8, 4, 19, 87, 8, 3, 49, 88, -97, -4, 24, 0, 6, 8, 1, 4, 8, 2, 3, 24, 3, 5, 88, 7, 19, 7, -8, 0, 19, 18, 8, 0, 19, 62, 8, 0, 18, -30, 8, 0, 35, -98, 60, 48, 4, 19, -110, 8, 3, 19, -78, 16, 1, 19, 77, 24, 0, 34, -86, 92, 8, 1, 32, -113, -114, 8, 1, 64, 88, -97, 83, -105, 8, 1, 81, 88, -98, 0, -18, 37, 0, 1, 49, 73, -27, 31, 8, 0, 12, 8, 1, 19, 11, -8, 0, 19, -101, 8, 0, 4, 40, 10, 19, 76, -72, 0, 19, -127, 8, 0, 4, 24, 5, 17, -62, 16, 0, 21, 87, 40, 9, 4, 32, 8, 2, 16, 4, 21, 87, 16, 4, 4, 8, 2, 4, 8, 1, 3, 8, 2, 20, -97, 0, 1, 18, 1, -40, 0, 3, 32, 4, 21, 87, 8, 1, 4, 24, 2, 4, 64, 5, 19, 39, 40, 0, -94, -102, -107, 44, -74, 32, 52, 88, -97, 62, -105, -24, 0, 19, 78, 24, 2, 19, 54, 40, 3, 17, 69, 40, 0, 66, 87, -97, 61, 96, 40, 0, 34, -92, -86, 8, 1, 32, 88, -19, 8, 1, 66, 87, -97, 12, -78, 40, 4, 32, 36, 54, 104, 9, 20, 87, 112, 16, 20, -98, 16, 1, 19, 30, 0, 1, 19, -90, 8, 0, 17, 14, -24, 0, 49, 88, -97, 83, 8, 0, 49, 87, -97, -122, 8, 0, 4, 40, 10, 51, 87, -97, -60, 16, 0, 0, 8, 1, 59, 32, 52, 87, 24, 7, 17, 87, 16, 3, 0, 8, 0, 2, 8, 1, 25, 87, 8, 2, 0, 48, 0, 2, 8, 1, 29, 87, 8, 1, 4, 0, 1, 4, 8, 0, 17, 10, -40, 0, 51, 88, -97, 30, 8, 0, 19, 120, 8, 0, 19, -76, 32, 3, 19, 2, 120, 9, 34, -52, -102, 88, 0, 19, -12, -8, 6, 32, 59, 94, -128, 0, 64, 88, -97, 38, -78, 8, 1, 64, 87, -97, -8, 20, 40, 4, 66, 87, -98, -59, 27, 72, 7, 36, -66, 7, 40, 4, 10, 24, 3, 19, 41, 0, 1, 19, -83, 8, 0, 18, 17, -24, 0, 20, -98, 40, 7, 18, -117, 16, 0, 3, 40, 8, 49, 87, -97, -58, 16, 0, 5, 32, 6, 20, -98, 8, 1, 2, 16, 2, 2, 24, 4, 0, 8, 0, 4, 24, 5, 10, 16, 3, 4, 8, 1, 6, 32, 5, 4, 24, 3, 4, 8, 0, 4, 32, 3, 4, 96, 8, 19, 26, 0, 1, 17, 111, 16, 2, 49, 87, -97, 116, 8, 1, 51, 87, -98, 64, 8, 3, 19, -16, 8, 0, 32, -63, -115, 16, 1, 66, 88, -97, -103, 86, -128, 0, 18, -71, 64, 7, 65, -98, 9, 24, 42, 56, 0, 32, 55, 60, 8, 1, 72, 87, -98, 106, 96, 8, 1, 5, 24, 2, 35, -97, 39, 0, 1, 4, 88, 14, 17, 15, -24, 0, 51, 88, -97, 85, 8, 0, 19, -120, 8, 0, 19, -83, 8, 0, 4, 8, 1, 19, -41, 16, 0, 19, -29, 8, 0, 4, 32, 5, 0, 24, 3, 0, -112, 0, 4, 8, 1, 0, 32, 5, 0, 16, 0, 3, 24, 3, 17, -98, 16, 2, 18, 51, 8, 1, 0, 24, 0, 4, 0, 1, 2, 8, 0, 6, 24, 2, 4, 8, 1, 19, 28, 8, 1, 4, 16, 2, 18, 97, 8, 1, 35, -97, -52, 32, 3, 19, 16, 8, 0, 34, -30, -121, 0, 1, 34, -72, 71, 88, 0, 32, 24, -116, 16, 2, 66, 88, -97, 8, -7, 24, 3, 32, 70, 28, 8, 1, 72, 88, -97, -5, 82, 8, 1, 6, 40, 4, 4, 16, 2, 19, -88, 16, 1, 19, 10, -40, 0, 19, 80, 8, 0, 19, -125, 8, 0, 3, 64, 13, 35, -98, -61, 16, 0, 0, 24, 3, 0, 72, 0, 2, 48, 7, 31, 87, 48, 9, 5, 20, -98, 32, 4, 19, -3, 56, 0, 12, 40, 6, 2, 32, 3, 5, 72, 8, 5, 40, 4, 4, 24, 3, 3, 32, 4, 33, -98, -108, 16, 2, 66, 88, -97, 112, -106, -120, 6, 19, 102, 0, 1, 18, 108, 88, 0, 50, -98, -120, 126, -112, 0, 32, -122, 46, 8, 0, 64, 87, -97, -48, 91, 8, 1, 64, 87, -97, -83, -78, 8, 1, 66, 88, -97, 23, -67, 32, 4, 32, 119, -27, 32, 4, 6, 0, 1, 4, 32, 3, 19, 115, 0, 1, 19, -93, 8, 0, 19, -1, 8, 0, 18, 72, 96, 0, 5, 104, 16, 19, -93, 16, 0, 4, 64, 10, 4, 64, 12, 19, -32, 24, 0, 2, 48, 6, 19, 88, 48, 6, 15, 56, 8, 7, 0, 24, 2, 0, -48, 0, 0, 16, 1, 0, 8, 0, 0, 8, 2, 0, -72, 2, 0, 8, 0, 0, -40, 5, 4, -128, 12, 19, 17, 8, 2, 19, 64, 8, 0, 19, -62, 8, 0, 17, -110, 16, 2, 51, 88, -97, -82, 8, 0, 33, -64, -113, 56, 0, 33, -97, -76, 88, 11, 66, 87, -97, -75, 5, 80, 0, 49, 66, 16, 43, 120, 2, 34, 114, 61, 8, 1, 34, 4, 24, 8, 1, 49, -9, 5, 33, 112, 5, 4, 0, 1, 4, 8, 0, 19, 60, 80, 0, 4, 72, 12, 19, -6, 8, 1, 19, 58, -32, 0, 19, 113, 8, 0, 3, 72, 10, 18, -98, 72, 10, 49, 88, -97, -52, 24, 0, 6, 64, 8, 17, -27, 16, 0, 6, 72, 12, 19, -13, 16, 0, 2, 48, 5, 6, 56, 6, 15, 48, 4, 5, 4, 32, 5, 4, 64, 8, 17, 36, -8, 0, 49, 87, -97, 119, 8, 0, 51, 88, -98, 8, -88, 0, 18, -99, 8, 0, 18, -98, -72, 6, 66, 88, -97, 126, -122, 8, 1, 34, -64, 82, 0, 1, 32, -74, -59, 8, 2, 64, 88, -97, 124, -94, 32, 5, 64, 88, -97, -30, -113, 72, 9, 66, 87, -97, 94, 26, 56, 7, 47, -14, -102, 56, 7, 3, 19, 63, -112, 9, 19, -68, 104, 2, 4, 64, 15, 4, 88, 15, 4, 72, 9, 19, -111, -40, 0, 4, 88, 14, 19, -59, 16, 0, 19, -44, 8, 0, 4, 24, 2, 19, -22, 16, 0, 2, 72, 8, 14, 56, 5, 4, 40, 3, 0, 16, 2, 0, -96, 0, 0, 8, 2, 0, 16, 2, 17, 9, -16, 0, 21, 87, 32, 6, 19, 86, 16, 0, 17, -52, 8, 0, 49, 88, -98, 90, 0, 1, 48, 87, -97, 0, 24, 3, 67, 52, 88, -97, 112, 8, 2, 34, -115, 115, 72, 0, 34, -57, 32, 8, 0, 34, -92, 99, 8, 1, 34, 5, 0, 8, 1, 34, 24, -102, 24, 4, 49, 19, -77, 35, 56, 8, 49, 44, -113, 29, 64, 0, 2, 8, 2, 6, 40, 5, 34, 47, 120, -64, 14, 32, 93, -66, 72, 0, 51, 88, -97, 125, -96, 8, 17, 10, 120, 0, 50, 88, -97, -50, -40, 0, 34, -98, -94, 8, 0, 4, 40, 4, 5, 32, 3, 4, 96, 14, 19, -38, 32, 0, 19, -26, 8, 0, 2, 64, 6, 21, 87, 96, 11, 2, 88, 9, 4, 56, 5, 2, 48, 8, 0, 24, 3, 4, 40, 8, 18, 34, -16, 0, 35, -97, 83, 8, 0, 19, -61, 8, 0, 19, 63, -120, 0, 17, 73, 8, 0, 51, 87, -97, -40, -8, 9, 34, -60, -127, -80, 0, 34, -48, 76, 8, 0, 34, 3, -52, 0, 1, 34, 117, -47, 32, 6, 34, -116, 17, 16, 3, 49, -75, 61, 38, 56, 0, 34, -110, -74, 24, 4, 32, -44, -93, -16, 22, 6, 0, 1, 2, 16, 1, 81, 88, -97, 8, -72, 51, 40, 1, 34, 105, 50, -16, 18, 34, 108, -13, 88, 0, 19, 28, -24, 14, 19, -50, -80, 8, 17, 85, -120, 0, 6, -48, 7, 19, -57, -16, 0, 4, 8, 0, 4, 56, 5, 10, 88, 9, 6, 16, 2, 0, 16, 3, 0, -8, 0, 12, 72, 12, 19, 50, -16, 0, 19, 105, 8, 0, 17, -36, 8, 0, 49, 87, -97, 88, 112, 0, 49, 87, -97, 104, 8, 0, 51, 88, -97, 7, 112, 0, 32, -74, -121, 72, 0, 66, 87, -97, -63, 96, -88, 0, 34, 22, 1, 8, 0, 34, -61, 65, 8, 1, 34, 121, -18, 0, 1, 34, -95, -69, 8, 2, 34, 79, 86, 80, 11, 34, 12, -33, -104, 17, 47, -66, -118, 104, 13, 3, 49, -45, 49, 96, 8, 1, 34, -100, -35, -64, 23, 34, -13, 97, 24, 22, 34, 109, -93, 40, 2, 34, 86, -28, 104, 0, 19, 14, 24, 1, 19, 50, 24, 1, 19, -14, -104, 0, 19, -53, 8, 0, 19, -35, 8, 0, 2, 56, 6, 21, 87, 56, 7, 4, 0, 7, 17, 27, -32, 0, 51, 88, -97, 54, 8, 0, 19, 93, 8, 0, 19, -89, 8, 0, 17, 41, -16, 2, 51, 87, -97, -88, -8, 0, 4, 16, 5, 19, 38, 88, 0, 32, 74, -119, -120, 0, 64, 87, -98, 38, 103, 8, 0, 66, 88, -97, 27, 22, 8, 0, 34, 117, 119, 0, 1, 34, -106, 99, 8, 3, 32, -72, -100, 16, 4, 66, 88, -97, 85, -32, 16, 4, 34, 44, -117, 8, 2, 34, -62, -39, 8, 2, 49, 19, -45, 16, 32, 0, 4, 8, 2, 4, 8, 0, 49, 121, -84, -17, 24, 0, 49, -6, 102, -118, 8, 0, 49, 101, -86, 77, 8, 0, 34, -68, -123, 80, 25, 34, -68, -122, 40, 22, 19, -41, 16, 19, 34, 91, -82, -128, 0, 2, 56, 10, 6, -32, 4, 19, 21, -48, 0, 4, 72, 16, 19, 66, 16, 0, 17, 102, 8, 0, 49, 87, -97, -112, 8, 0, 51, 88, -97, -48, 8, 0, 18, 54, -16, 0, 33, -98, -46, 8, 0, 64, 87, -97, 61, -105, -24, 1, 51, 88, -98, -90, 16, 0, 19, 52, -80, 5, 19, 2, 24, 8, 34, -22, 99, 120, 0, 33, 4, 21, 40, 0, 50, -97, -16, -126, 0, 1, 34, -86, -113, 0, 1, 34, -21, 4, 8, 2, 34, 125, -84, 8, 3, 34, 91, 32, 16, 4, 34, 24, -115, 88, 13, 49, 88, 72, 21, -40, 0, 49, 11, -36, 8, 8, 0, 4, 0, 1, 4, 8, 0, 64, -105, -123, -104, -73, -96, 0, 49, 21, -61, 31, 8, 0, 49, 65, 55, -83, 40, 0, 49, 35, 69, 101, 8, 0, 49, -110, 97, 59, 8, 0, 34, 39, -122, 32, 2, 17, 108, -88, 0, 51, 88, -97, 42, 8, 0, 19, 17, 8, 0, 19, 20, 8, 0, 19, 48, 8, 0, 19, 100, 8, 0, 19, -102, 8, 0, 19, -18, 8, 0, 18, 113, -112, 5, 34, -98, 16, 8, 10, 34, -98, -22, 16, 0, 35, -97, -11, 32, 1, 17, -51, 0, 5, 66, 87, -97, -76, 126, -16, 0, 32, 111, 84, 0, 1, 64, 87, -97, -42, -6, -8, 0, 64, 87, -97, -118, 100, 8, 0, 66, 88, -97, -65, 122, 0, 1, 34, 45, 12, 0, 1, 32, -1, -18, 0, 1, 66, 88, -97, -34, -52, 0, 1, 34, 48, -6, 8, 3, 49, 109, -62, 23, -64, 0, 49, -69, 98, 13, 8, 0, 63, 7, 126, -4, -104, 19, 2, 19, 83, -24, 20, 32, 29, -63, 112, 0, 66, 88, -97, 85, -100, 40, 4, 34, -113, -88, 16, 0, 34, 41, -94, 8, 0, 19, 36, 32, 19, 17, -36, -32, 14, 6, 104, 22, 19, -39, -24, 11, 19, -114, 8, 0, 17, 123, 8, 0, 51, 87, -97, 99, 8, 0, 19, -120, 8, 0, 19, -65, 8, 0, 17, -109, 8, 0, 49, 88, -97, 45, 0, 1, 48, 87, -97, -109, 24, 12, 82, 51, 87, -97, -16, -124, 104, 0, 34, 125, 104, 0, 1, 34, 26, 45, 16, 0, 34, 17, -69, -8, 0, 49, -50, 18, 43, 32, 11, 34, -36, 31, 0, 1, 34, 1, -75, 0, 3, 34, 91, -82, 0, 1, 34, -37, -72, 0, 1, 33, -115, 98, 24, 7, 65, -98, 56, -32, 24, -8, 0, 49, 105, -96, 15, 8, 0, 49, 24, 49, 2, 8, 0, 63, 0, 46, -32, 8, 1, 2, 18, -6, -104, 1, 50, -97, 89, -56, 120, 0, 18, -83, -24, 18, 35, -97, 121, 24, 1, 34, -52, -73, 24, 0, 34, -55, -81, 8, 0, 34, -69, -87, 8, 0, 34, -63, -91, 8, 0, 19, 26, -104, 25, 19, 122, 0, 15, 18, -121, 48, 1, 35, -98, -34, 120, 6, 17, 84, 80, 4, 49, 87, -97, -124, -16, 1, 64, 87, -97, -39, -116, 56, 0, 66, 87, -97, -90, 125, 8, 0, 34, 118, 97, 8, 0, 17, 32, -8, 0, 64, 87, -98, 49, -48, -8, 0, 64, 87, -97, 114, 56, 8, 0, 66, 88, -97, 20, 112, -8, 0, 34, -98, 95, -8, 1, 34, -100, -28, 0, 5, 34, 86, -37, 0, 4, 34, 119, -19, 40, 11, 34, -61, -67, 0, 2, 34, 111, -110, 0, 1, 34, 23, -14, 0, 1, 34, 7, -41, -88, 22, 49, 105, -5, -27, 0, 1, 49, 38, 24, -70, 8, 0, 4, 16, 3, 4, 8, 0, 34, 49, 27, 96, 0, 34, -66, 3, 120, 0, 34, -79, -4, 8, 0, 32, 65, 105, -96, 0, 48, 88, -97, -17, -80, 1, 66, 52, 88, -97, -20, -32, 0, 35, -97, -82, 88, 23, 17, -54, -32, 0, 49, 88, -97, -64, -32, 0, 49, 88, -97, -90, -48, 2, 51, 88, -97, -117, -40, 8, 34, 14, 122, 64, 0, 19, -19, 72, 0, 34, -75, 81, 16, 0, 34, 29, 43, 8, 0, 32, 96, -20, 104, 0, 64, 87, -98, 42, -117, 8, 0, 66, 88, -97, 72, -7, -16, 0, 32, -125, 48, 8, 0, 64, 87, -97, -39, 57, -104, 0, 66, 87, -97, 109, 2, -8, 1, 34, 18, 105, -8, 1, 34, 81, 59, 0, 6, 34, -27, 43, 0, 5, 34, -41, -21, 120, 20, 19, -20, 112, 19, 34, -51, 106, -104, 22, 34, -96, 8, 0, 1, 49, 45, 99, -26, -8, 0, 49, -49, 127, -67, 8, 0, 49, -92, 66, -113, 8, 0, 4, 0, 1, 4, 8, 0, 34, -99, -122, 64, 1, 33, 7, 51, 80, 2, 50, -97, -118, -74, 96, 2, 34, 16, 8, 120, 1, 32, -85, 37, -112, 0, 64, 88, -97, -46, 83, -96, 0, 66, 88, -97, -66, -20, 8, 0, 19, -21, -80, 1, 34, 65, 95, -56, 0, 34, -48, 123, 8, 0, 34, 63, 125, 8, 0, 34, 101, 103, 8, 0, 34, -68, 54, 8, 0, 34, -30, -25, 56, 0, 34, 33, 120, 8, 0, 34, -41, -30, 88, 0, 34, -127, 39, 8, 0, 34, -17, 37, -16, 0, 32, 9, 0, 120, 0, 66, 87, -98, -96, -94, -16, 1, 34, 27, -43, -112, 0, 34, -77, 98, -8, 0, 34, 89, 13, -8, 1, 34, 35, -114, -72, 26, 49, 101, 89, 19, -88, 1, 34, 52, -39, -48, 27, 49, -126, 61, -1, -24, 0, 34, 86, 119, 0, 3, 34, 10, -84, 0, 2, 49, 31, -92, -112, 24, 0, 49, 31, -34, 68, 8, 0, 4, 0, 1, 15, 8, 0, -7, 15, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 66, 31, 14, 61, 25, -1, -11, 31, 28, 8, 2, -1, -11, 31, 43, 8, 2, -1, -11, 31, 33, 8, 2, -1, -19, 19, 9, 0, 2, 19, 13, 8, 0, 15, 2, 0, -1, -26, 31, 49, -7, 1, -1, -26, 3, 2, 0, 19, 11, 8, 0, 19, 41, 8, 0, 15, 2, 0, -1, -26, 19, 64, -7, 1, 15, 16, 6, -1, -26, 19, 48, 0, 2, 19, 32, 8, 0, 15, 2, 0, -1, -34, 19, 46, -15, 1, 19, 39, 8, 0, 19, 1, 8, 0, 15, 2, 0, -1, -50, 4, 8, 12, 19, 61, -23, 1, 4, 0, 4, 19, 2, 16, 0, 15, 2, 0, -1, -58, 19, 10, -39, 1, 19, 47, 8, 0, 19, 37, 8, 0, 15, 0, 8, -1, -50, 27, 3, -24, 1, 19, 12, 16, 0, 15, -16, 5, -1, -42, 15, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -16, 80, 0, 0, 0, 0, 0 });
	private final Pointer PARAM_2 = new Pointer(1000000);
	private final Pointer STACK = new Pointer(1000000);
	
	private static final boolean hexString = true;
	private static final boolean logStuff = true;
	
	public static String getHexString(byte[] bytes, int start, int maxLength, int lineLength) {
		StringBuilder sb = new StringBuilder();
		int a = 1;
		for(int i = start; i < Math.min(bytes.length, start + maxLength); i++) {
			sb.append(String.format("%02x", bytes[i]));
			if((a ++) % lineLength == 0) sb.append('\n');
		}
		
		return sb.toString();
	}
	
	public static String getHexString(Pointer p, int start, int maxLength, int lineLength) {
		return getHexString(p.data(), start, maxLength, lineLength);
	}
	
	private long Decompress(Address entry) {
		// mipIndex = 352
		// int compressedSize = 4864; // 4864
		int size = 42512;
		
		// __fastcall
		// EAX:4			int		<RETURN>
		// ECX:4			byte*	input
		// EDX:4			int*	param_2
		// Stack[0x4]:4		int		size
		
		System.out.println(regs);
		setValue("ESP", 0x70000000 + 2500000); // Stack Address
		setValue("ECX", 0x70000000 + 1000000);
		setValue("EDX", 0x70000000 + 2000000);
		
		setExpression("dword ptr [ESP + 0x8]", size);
		
		call.push(null);
		
		Instruction inst = getInst(entry);
		for(int i = 0; i < 100000; i++) {
			// if(monitor.isCancelled()) break;
			
			inst = executeInstruction(inst);
			if(inst == null) break;
		}
		
		String str = getHexString(PARAM_2, 0, size, 64);
		
		System.out.println(getHexString(STACK, (STACK.data().length / 2) - 96, 96, 32));
		System.out.println(getHexString(PARAM_2, 0, 320, 64));
		
		Clipboard clip = Toolkit.getDefaultToolkit().getSystemClipboard();
		clip.setContents(new StringSelection(str), null);
		
		return getRegister("EAX").value();
	}
	
	private String[] splitInstruction(Instruction inst) {
		String[] split = new String[inst.getNumOperands()];
		
		for(int i = 0; i < split.length; i++) {
			split[i] = inst.getDefaultOperandRepresentation(i);
		}
		
		return split;
	}
	
	private Instruction executeInstruction(Instruction inst) {
		if(logStuff) {
			System.out.println("\n------------------------------------------------");
			System.out.println(inst.getAddress() + ", " + inst.toString());
		}
		String[] split = splitInstruction(inst);
		
		String mn = inst.getMnemonicString();
		Instruction next = inst.getNext();
		Address jmpS = null;
		switch(mn) {
			case "PUSH": getRegister(split[0]).push(); break;
			case "POP": getRegister(split[0]).pop(); break;
			case "MOV": MOV(split); break;
			case "SUB": SUB(split); break;
			case "TEST": TEST(split); break;
			case "CMP": CMP(split); break;
			
			case "JMP":
			case "JNZ":
			case "JA":
			case "JZ":
			case "JC":
			case "JNC":
			case "JBE": jmpS = JUMP(mn, split); break;
			
			case "OR": OR(split); break;
			case "RET": next = getInst(call.poll()); break;
			case "LEA": LEA(split); break;
			case "SETZ": SETZ(split); break;
			case "MOVZX": MOVZX(split); break;
			case "INC": getRegister(split[0]).inc(); break;
			case "DEC": getRegister(split[0]).dec(); break;
			case "SHR": SHR(split); break;
			case "AND": AND(split); break;
			case "ADD": getRegister(split[0]).add(getValue(split[1])); break;
			case "CALL": jmpS = CALL(inst, split); break;
			case "NOP": break;
			case "XOR": XOR(split); break;
			
			default: {
				System.err.println("IMPL: " + mn);
				System.err.println("INP: " + arrToStr(split));
				
				return null;
			}
		}
		
		if(logStuff) {
			StringBuilder sb = new StringBuilder();
			for(RLong r : regs.values()) if(r.name.charAt(0) == 'E' && r.name.length() == 3) sb.append(r.name).append("=").append(r.toString()).append(", ");
			sb.append("\n\n");
			for(RLong r : regs.values()) if(r instanceof RFlag) sb.append(r.name).append("=").append(r.toString()).append(", ");
			sb.append("\n\n");
			System.out.println(sb.toString());
		}
		
		if(jmpS != null) return getInst(jmpS);
		return next;
	}
	
	private Address CALL(Instruction curr, String[] split) {
		long offset = getValue(split[0]);
		// 0x00d20240
		
		if(offset == 0x00d20240) { // (C++) memmove
			long idst = getValue("ESI");
			long isrc = getValue("EBX");
			long num = getValue("EDX");
			
			// void * memmove ( void * destination, const void * source, size_t num );
			Region rdst = MEMORY.getRegionContaining(idst);
			if(rdst == null) throw new NonImpl();
			idst -= rdst.start;
			
			Region rsrc = MEMORY.getRegionContaining(isrc);
			if(rsrc == null) throw new NonImpl();
			isrc -= rsrc.start;
			
			Pointer dst = rdst.memory();
			Pointer src = rsrc.memory();
			
			dst.push();
			src.push();
			dst.set((int)idst);
			src.set((int)isrc);
			dst.WriteBytes(src.Bytes((int)num));
			src.pop();
			dst.pop();
			
			return curr.getNext().getAddress();
		}
		
		call.push(curr.getNext().getAddress());
		return getAddr(offset);
	}
	
	private void XOR(String[] split) {
		RLong r = getRegister(split[0]);
		r.set(r.value() ^ getValue(split[1]));
		
		setFlag("CF", false);
		setFlag("OF", false);
	}
	
	private void AND(String[] split) {
		RLong r = getRegister(split[0]);
		r.set(r.value() & getValue(split[1]));
	}
	
	private void SHR(String[] split) {
		RLong r = getRegister(split[0]);
		r.set(r.value() >>> getValue(split[1]));
	}
	
	private void MOVZX(String[] split) {
		// MOVZX is the same as this but MOVZX is needed for assembly
		MOV(split);
	}
	
	private void SETZ(String[] split) {
		setValue(split[0], getFlag("ZF"));
	}
	
	private void CMP(String[] split) {
		long a = getValue(split[0]);
		long b = getValue(split[1]);
		long c = a - b;
		
		setFlag("ZF", c == 0);
		setFlag("CF", b > a);
		setFlag("OF", false); // TODO - (OF) flag
	}
	
	private Address JUMP(String mn, String[] split) {
		long ZF = getFlag("ZF");
		long CF = getFlag("CF");
		
		boolean jump = false;
		switch(mn) {
			case "JMP": jump = true; break;
			case "JNZ": jump = (ZF == 0); break;
			case "JZ":  jump = (ZF == 1); break;
			case "JC":  jump = (CF == 1); break;
			case "JNC": jump = (CF == 0); break;
			case "JA":  jump = (CF == 0) && (ZF == 0); break;
			case "JBE": jump = (CF == 1) || (ZF == 1); break;
			default:
				throw new NonImpl();
		}
		
		if(jump) return getAddr(getValue(split[0]));
		return null;
	}
	
	private void MOV(String[] split) {
		long result = getValue(split[1]);
		setValue(split[0], result);
	}
	
	private void LEA(String[] split) {
		long result = getValue(split[1]);
		RType type = getType(split[0]);
		if(type != RType.REGISTER) throw new NonImpl();
		
		setValue(split[0], result);
	}
	
	private void OR(String[] split) {
		RLong reg = getRegister(split[0]);
		
		long a = reg.value();
		long b = getValue(split[1]);
		
		// Cleared
		setFlag("CF", 0);
		setFlag("OF", 0);
		
		// NOTE - Must use size specifier with data pointers
		reg.set(a | b);
	}
	
	private void TEST(String[] split) {
		long a = getValue(split[0]);
		long b = getValue(split[1]);
		long c = a & b;
		
		setFlag("ZF", c == 0);
		setFlag("OF", false);
		setFlag("SF", c < 0);
		// setRegister("PF", c == 0); // TODO - PF
	}
	
	private void SUB(String[] split) {
		RLong reg = getRegister(split[0]);
		reg.sub(getValue(split[1]));
	}
	
	private void setFlag(String name, long value) { setFlag(name, !(value == 0)); }
	private void setFlag(String name, boolean value) {
		if(!regs.containsKey(name)) {
			throw new NonImpl();
		}
		
		RLong r = regs.get(name);
		if(!(r instanceof RFlag)) throw new NonImpl();
		
		r.set(value ? 1:0);
	}
	private long getFlag(String name) {
		if(!regs.containsKey(name)) {
			throw new NonImpl();
		}
		
		RLong r = regs.get(name);
		if(!(r instanceof RFlag)) throw new NonImpl();
		
		return r.value();
	}
	private RLong getRegister(String name) {
		if(!regs.containsKey(name)) throw new NonImpl();
		RLong r = regs.get(name);
		if(r instanceof RFlag) throw new NonImpl();
		return r;
	}
	private void setValue(String str, long value) {
		RType type = getType(str);
		
		switch(type) {
			case CONSTANT: throw new NonImpl(); // Illegal
			case REGISTER: getRegister(str).set(value); break;
			case EXPRESSION: setExpression(str, value); break;
		}
	}
	
	private long getValue(String str) {
		RType type = getType(str);
		
		switch(type) {
			case CONSTANT: return getConstantValue(str);
			case REGISTER: return getRegister(str).value();
			case EXPRESSION: return getExpression(str);
		}
		
		return 0L;
	}
	
	private void setExpression(String str, long value) {
		Expr exp = solveExpression(str);
		
		if(exp.ptr) {
			Region r = MEMORY.getRegionContaining(exp.index);
			if(r == null) throw new NonImpl();

			int index = (int)(exp.index - r.start);
			if(logStuff) System.out.println("ptr -> " + exp + ", index = " + String.format("%08x  new = %08x", exp.index, index));
			
			Pointer p = r.memory();
			switch(exp.size) {
				case BYTE: p.WriteByte((int)value, index); break;
				case WORD: p.WriteShort((int)value, index); break;
				case DWORD: p.WriteInt((int)value, index); break;
			}
		} else {
			// Illegal
			throw new NonImpl();
		}
		
		if(logStuff) System.out.println("setExpression -> " + exp);
	}
	
	private long getExpression(String str) {
		Expr exp = solveExpression(str);
		if(logStuff) System.out.println("getExpression -> " + exp);
		
		if(exp.ptr) {
			Region r = MEMORY.getRegionContaining(exp.index);
			if(r == null) throw new NonImpl();
			
			int index = (int)(exp.index - r.start);
			if(logStuff) System.out.println("ptr -> " + exp + ", index = " + String.format("%08x  new = %08x", exp.index, index));
			
			long var = 0;
			Pointer p = r.memory();
			switch(exp.size) {
				case BYTE: var = p.UnsignedByte(index); break;
				case WORD: var = p.UnsignedShort(index); break;
				case DWORD: var = p.UnsignedInt(index); break;
				default: throw new NonImpl();
			}
			
			if(logStuff) System.out.printf("ptr -> v:[%08x]  value = '%d'\n", var, var);
			
			return var;
		} else {
			return exp.index;
		}
	}
	
	private Expr solveExpression(String string) {
		Expr exp = new Expr();
		
		int ptr_index = string.indexOf("ptr");
		if(ptr_index != -1) {
			
			String size = string.substring(0, string.indexOf(' '));
			exp.size = RSize.valueOf(size.toUpperCase());
			exp.ptr = true;
			
			string = string.substring(ptr_index + 4);
			exp.expression = string;
		} else {
			exp.expression = string;
		}
		
		// Combine all multiplications and separate all additions and subtractions
		string = '+' + string.substring(1, string.length() - 1);
		string = string.replaceAll("[ ]+\\*[ ]+", "*"); // combine mul
		string = string.replace("+", " + ").replace("-", " - ");
		
		String[] arr = string.split("[ ]+");
		
		long index = 0;
		boolean add = false;
		boolean sub = false;
		for(String s : arr) {
			if(s.trim().isEmpty()) continue;
			
			if(s.equals("+")) {
				add = true; sub = false;
				continue;
			}
			
			if(s.equals("-")) {
				add = false; sub = true;
				continue;
			}
			
			boolean mul = s.indexOf("*") != -1;
			
			long v = 0;
			if(mul) {
				String[] segs = s.split("\\*");
				v = getValue(segs[0]);
				
				for(int i = 1; i < segs.length; i++) v *= getValue(segs[i]);
			} else v = getValue(s);
			
			if(add) index += v;
			if(sub) index -= v;
			
			// System.out.printf("%s = '%08x' (%d)\n", s, v, v);
		}
		exp.index = index;
		
		// TODO - Check if index is inside stack
		// System.out.println("Solve '" + string + "' calc = '" + index + "'");
		// System.out.println("Exp '" + exp + "'");
		
		return exp;
	}
	
	private Instruction getInst(Address addr) {
		if(addr == null) return null;
		//return getInstructionAt(addr);
		return INSTRUCTIONS.get(addr.toString());
	}
	
	private long getConstantValue(String str) {
		boolean neg = false;
		if(str.startsWith("-")) {
			neg = true;
			str = str.substring(1);
		}
		
		if(str.startsWith("0x")) { // Hex
			str = str.substring(2);
			return Long.valueOf(str, 16) * (neg ? -1:1);
		}
		
		//  01 - base  8
		//  10 - base 10
		//  1h - base 10
		// 0x1 - base 16
		
		return Long.valueOf(str) * (neg ? -1:1);
	}
	
	private Address getAddr(long l) {
		//return getAddressFactory().getAddress(Long.toHexString(l)); }
		return new Address(l);
	}
	
	private RType getType(String str) {
		if(str.indexOf('[') > -1 || str.indexOf(']') > -1) return RType.EXPRESSION;
		if(str.startsWith("-0x") || str.startsWith("0x")) return RType.CONSTANT;
		return RType.REGISTER;
	}
	
	private String arrToStr(String[] arr) {
		StringBuilder sb = new StringBuilder().append("[ ");
		for(String s : arr) sb.append(s).append(", ");
		if(arr.length > 0) sb.deleteCharAt(sb.length() - 2);
		return sb.append("]").toString();
	}
	
	private enum RSize { BYTE, WORD, DWORD /*, QWORD */ }
	private enum RType { EXPRESSION, CONSTANT, REGISTER }
	
	private class Expr {
		public boolean stack;
		public boolean ptr;
		
		public RSize size;
		public String expression;
		public long index;
		
		@Override
		public String toString() {
			String str = "Expr '" + expression + "' index=" + index;
			
			if(stack) str += " [Stack]";
			if(ptr) str += " [Pointer " + size + "]";
			
			return str;
		}
	}
	
	class RFlag extends RLong {
		public RFlag(String name, boolean set) {
			super(name, set ? 1:0);
		}
		
		public void pop() { throw new NonImpl(); }
		public void push() { throw new NonImpl(); }
		public long value() { return super.value() == 0 ? 0:1; }
		public void set(long value) { super.set(value == 0 ? 0:1); }
		public String toString() { return Long.toString(value()); }
	}
	
	class RSLong extends RLong {
		private final long offset;
		private final RSize size;
		private final RLong reg;
		
		private RSLong(String name, int offset, RSize size, RLong reg) {
			super(name, 0);
			this.reg = reg;
			this.offset = offset;
			this.size = size;
		}
		
		public void set(long value) {
			super.set(value);
			long byte_size = ((long)Math.pow(2, size.ordinal())) * 8L;
			
			//  byte -  8
			//  word - 16
			// dword - 32
			long mask = (1L << (byte_size)) - 1;
			long vals = value & mask;
			
			vals <<= offset;
			mask <<= offset;
			long parent = reg.value();
			parent &= ~mask;
			parent |= vals;
			reg.set(parent);
		}
		
		public long value() {
			long byte_size = ((long)Math.pow(2, size.ordinal())) * 8L;
			long mask = ((1L << (byte_size)) - 1) << offset;
			long val = (reg.value() & mask) >>> offset;
			
			switch(size) {
				case BYTE: return (byte)val;
				case WORD: return (short)val;
				case DWORD: return (int)val;
			}
			
			return val;
		}
		
		public void push() {
			if(size == RSize.BYTE) throw new NonImpl();
			super.push();
		}
		
		public void pop() {
			if(size == RSize.BYTE) throw new NonImpl();
			super.pop();
			set(super.value());
		}
		
		@Override
		public String toString() {
			long val = value();
			
			if(hexString) {
				switch(size) {
					case BYTE: return String.format("%02x", (byte)value());
					case WORD: return String.format("%04x", (short)value());
					case DWORD: return String.format("%08x", (int)value());
				}
			} else {
				switch(size) {
					case BYTE: return Byte.toString((byte)value());
					case WORD: return Short.toString((short)value());
					case DWORD: return Integer.toString((int)value());
				}
			}
			
			
			return Long.toUnsignedString(val);
		}
	}
	
	class RLong {
		public final String name;
		protected LinkedList<Long> list;
		
		public RLong(String name, long value) {
			this.name = name;
			this.list = new LinkedList<>();
			this.list.add(value);
		}
		
		public void push() { list.addLast(value()); }
		public void pop() { list.removeLast(); }
		public long value() { return list.getLast(); }
		public void set(long value) { list.set(list.size() - 1, value); }
		
		public void sub(long value) { set(value() - value); }
		public void add(long value) { set(value() + value); }
		public void mul(long value) { set(value() * value); }
		public void inc() { add(1); }
		public void dec() { sub(1); }
		
		@Override
		public int hashCode() {
			return name.hashCode();
		}
		
		@Override
		public boolean equals(Object obj) {
			if(obj instanceof String) {
				String val = obj.toString();
				
				char f = val.charAt(0);
				if(f == 'R') return name.equals(val);
				if(f == 'E') return name.substring(1).equals(val.substring(1));
				if(val.length() == 2) {
					if(name.substring(1).equals(val)) return true;
					if(name.charAt(1) == f) return true;
				}
				
				if(val.length() == 3) {
					return name.substring(1).equals(val.substring(0, 2));
				}
				
				return false;
			}
			if(obj instanceof Long) {
				return ((Long)obj).longValue() == value();
			}
			if(obj instanceof RLong) {
				return ((RLong)obj).value() == value();
			}
			return false;
		}
		
		public String toString() {
			if(hexString) return String.format("%016x", value());
			return Long.toString(value());
		}
	}
	
	private class NonImpl extends Error {
		private static final long serialVersionUID = -4539765818115105110L;
	}
	
	class Region {
		private String name;
		private Pointer ptr;
		private long start;
		private long size;
		
		public Region(String name, Pointer ptr, long start, long size) {
			this.name = name;
			this.start = start;
			this.size = size;
			this.ptr = ptr;
		}
		
		public long min() { return start; }
		public long max() { return start + size; }
		
		public boolean contains(long address) {
			return min() <= address && max() > address;
		}
		public boolean contains(Region r) {
			return min() <= r.max() && max() > r.min();
		}
		
		public Pointer memory() { return ptr; }
		public String toString() { return name; }
	}
	
	class MemoryRegion {
		private final List<Region> regions;
		
		public MemoryRegion() {
			regions = new ArrayList<>();
		}
		
		public void addRegion(String name, Pointer ptr, long start, long size) {
			regions.add(new Region(name, ptr, start, size));
		}
		
		public Region getRegionContaining(long address) {
			for(Region r : regions) {
				if(r.contains(address)) return r;
			}
			return null;
		}
	}
	
	class Address {
		private long index;
		
		public Address(String address) {
			this(Long.valueOf(address, 16));
		}
		
		public Address(long offset) {
			this.index = offset;
		}
		
		public long offset() {
			return index;
		}
		
		public String toString() {
			return String.format("%08x", index);
		}
	}
	
	class Instruction {
		private final Address address;
		private final Address next;
		private final String mnemonic;
		private final int operands;
		private final String[] split;
		public Instruction(String[] split) {
			this.split = split;
			address = new Address(split[0]);
			next = new Address(split[1]);
			mnemonic = split[2];
			operands = split.length - 3;
		}
		
		public String getMnemonicString() { return mnemonic; }
		public int getNumOperands() { return operands; }
		public Instruction getNext() { return getInst(next); }
		public Address getAddress() { return address; }
		public String getDefaultOperandRepresentation(int i) { return split[i + 3]; }
		
		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder();
			sb.append(mnemonic).append(" ");
			for(int i = 0; i < operands; i++) sb.append(getDefaultOperandRepresentation(i)).append(", ");
			
			if(operands > 0) {
				sb.deleteCharAt(sb.length() - 1);
				sb.deleteCharAt(sb.length() - 1);
			}
			
			return sb.toString();
		}
	}
}
